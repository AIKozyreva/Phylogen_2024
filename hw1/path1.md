## Mito Eve HW1

Task1: https://docs.google.com/document/d/1uV-HjQk-K1WCGMnkjM_lkI4p4QMIK8H3qZJAHX2oQVI/edit 

my_workdir: /mnt/.../kozyreva_works/230924_phylo_hw/human_mt_haplo

Raw_input_data: https://figshare.com/ndownloader/files/30768763 
 
Neanderthal samples: https://figshare.com/ndownloader/files/30768766 

Denisovan samples: https://figshare.com/ndownloader/files/30768775 

 ### Step1
 Создание окружения, установка mafft, iqtree2, jupyterlab. 
```
conda create -n phylo_hw
conda activate phylo_hw
conda install -c bioconda mafft
conda install -c bioconda iqtree2
conda install -c bioconda jupyterlab
```
### Step2
В директории human_mt_haplo, которую мы скачали из {Raw_input_data} лежит несколько .fasta. Чтобы выровнять все друг на друга, нужно сделать мультивыравнивание, для него нужна мультифаста - это когда несколько фаст просто конкатенируют вместе. Сначал мы создадим такую общую combined.fasta, а потом проведём выравнивание by mafft.

```
cat human_mt_haplo/*.fasta > comb_hum_mt_haplo.fasta
grep -c ">" comb_hum_mt_haplo.fasta #получим 45 по количеству входных .fasta файлов
```

```
mafft --kimura 1 --clustalout --maxiterate 1000 --thread 8 --auto comb_hum_mt_haplo.fasta > hum_MT_haplo.aln
```

ПАРАМЕТРЫ: `--kimura 1` - позволяет скорректировать построенное выравнивание с учётом того, что в биологии транзиции (пурин-пуриновые или пиримидин-пиримидиновые замены, T-C и/или A-G) происходят чаще, чем трансверсии (пурин-пиримидиновые замены, T-AG C-AG и/или A-TC G-TC), `--clustalout` - задаёт формат  выходных файлов (можно брать разные, в основном программы построения деревьев едят все форматы, предлагаемые мафтом), `--maxiterate 1000` - задаёт количество итераций (перестроек) выравнивания.

 ![image](https://github.com/user-attachments/assets/7bb0cc19-bf85-4e0c-83bc-34baefde107e)

`--thread 8` - задаёт количество парллельных потоков (чем больше потоков, тем в теории быстрее пойдёт процесс, потому что N фаайлов будут обрабатывать паралллельно, но на самом деле нет, потому что сверху эту логику ограничивает самый медленный нераспараллеленный субпроцесс - эт называется, оказывается, закон Амдала), `--auto` - программа сама автоматически подбирает оптимальный режим выравнивания. 

![image](https://github.com/user-attachments/assets/6f86174a-d0c9-4695-a91a-bbb86d3d9f26)

Параметр `--kimura 1` в MAFFTе помогает немного скорректировать выравнивание, но эта программа не предусматривает широкий функционал для построения матриц, на которых базируются деревья или которые моргут брать как сырьё некоторые сложные алгоритмы построения филогенетических деревьев. В софте, который создан для построения филогенетических деревьев можно использовать и другие математические модели, у которых тот же функционал и та же цель - корректная оценка и уточнение эволюционных расстояний и взаимного положения последовательностей (и скорости эволюции, насколько я поняла???). 

Можно почитать описания этих моделей где-нибудь, но важно понимать какие модели в каких случаях используют. В основном это зависит от типа входных данных и того, что вы о них знаете, например разительно ли далеки последовательности по GC состав, насколько много эволюционных изменений вы предполагаете, знаете или предполагаете ли вы что-то о частоте встречаемости каждого из нуклеотидов и о потенциальной частоте (или разнице частот) замен между ними. Есть очень сложные математические модели, включающие в себя множество параметров, но мне они не нужны и даже вредны, потому что мои данные - это митохондрии, которые у всех выполняют одинаковую функцию, не меняются внешне, вообще не так уж и активно меняются в смысловом плане, поэтому мне хватит обычной можеди, которая учитывает разную частоту замен между основаниями разных типов. 

### Step3
Строим by iqtree2 филогенетическое дерево по полученному в предыдущем шаге выравниванию {hum_MT_haplo.aln}.  

```
iqtree2 -s hum_MT_haplo.aln -bb 1000 -m MFP -nt 16
```
ПАРАМЕТРЫ: `-s` - далее указываете обрабатываемый файл выравнивания, `-bb 1000` - указываете количество итераций для расчёта bootstrep поддержки ветвей дерева (короче n раз дерево случайно перестроится, не помню целиком или каждая ветка отдельно, но для каждой ветки мы получим значение того, насколько НЕслучайно она оказывается в этом конкретносм месте, с учётом N построения случайных деревьев. обычно бутстреп от 0 до 100 потому что в %, но эт не обязательно. чем выше бутстреп тем лучше. если у ветки буутстреп мал - значит, выше вероятность, что ветка оказалась в этом месте чисто случайно и если вы немного поменяете датасет, она пропадёт),`-m MFP` - активирует модуль (по факту внутри тоже ml-модель), которая подбирает оптимальную модель замен-частоты для оценки эволюционных расстояний (то, что расписано выше),`-nt AUTO` - автоматическое обнаружение доступных потоков и установка на всех них (будьте осторожны с этим, если у вас есть какие-то параллельные процессы. лучше тогда пропишите сами конкретное число, например, 8 или 16). 

Ещё я их не использовала, но полезные параметры - на самом деле их просто оень много, мне не хочется всёвписывать, но вот этот `-o TAXON` - задаёт таксон, который сразу будет воспринят как аутгруппа. вообще это потом вручную можно сделать, но можно и так.

на выходе получим несколько файлов с деревьями `.iqtree`, `.contree`, `.treefile`. Лучшее дерево под форматом `.contree`, его и анализирую дальше. 

### Step4
Есть разные спосообы сложной визуализации деревьев (например, биб-ки для R и python), он удобны если вы умный, у вас есть время почитать про библиотеки и поучиться, и они полезны и удоробны, если вы прям жёско филогенетик миллион деревьев для статьи. Ни один из пунктов про меня не скажешь, поэтому я буду пользоваться такой волшебной вещью как **ITOl** (https://itol.embl.de/ ) , потому что у него есть графическая веб версия, бесплатный функционал широкий и он делает красивую картинку. Осторожнее, коли у вас нет платного аккаунта при перезагрузке странички рискуете потерять выставляемые вручную настройки. 

Этого можно избежать - если у вас есть а) шаблоны для метаданных (у меня есть), б) вы знаете, что можно сделать заблаговременный экспорт всех настроек через маленькую менюшку экспорта (там не только экспорт картинок да, я узнала это после траты 3х часов жизни впустую, ну опыт - сын ошибок трудных). 

![image](https://github.com/user-attachments/assets/8749e3b4-460a-459c-b94c-39eb6d4d711e)


Вот просто визуализация выходного файла .contree полученного в результате работы iqtree2. Три варианта визуализации, дерево не укоренено специфически (это на прямоугольном и круглом дереве вы видите дефолтное укоренение), и это без вообще каких-либо дополнительных метаданных. Красивые accsessions в названии ветвей - это результата красивого имени каждой записи в моей выравниваемой мультифасте {comb_hum_mt_haplo.fasta} из **Step2**. 

Вот с отображением бутстрепов и эволюц.расстояний в виде "as age", и "re-root at midpoint" - опции ITOL. 
 ![LHSnAp0r-iSpGHMVodwowg](https://github.com/user-attachments/assets/1f76edcd-6f97-46e5-901e-ce8bd7ded658)
